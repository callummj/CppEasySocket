//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : Client.sm
//

#include "pch.h"
#include "Client.h"
#include "Client_sm.h"

using namespace statemap;

// Static class declarations.
ClientMap_Disconnected ClientMap::Disconnected("ClientMap::Disconnected", 0);
ClientMap_Connecting ClientMap::Connecting("ClientMap::Connecting", 1);
ClientMap_Connected ClientMap::Connected("ClientMap::Connected", 2);
ClientMap_Disconnecting ClientMap::Disconnecting("ClientMap::Disconnecting", 3);
ClientMap_Disposed ClientMap::Disposed("ClientMap::Disposed", 4);

void ClientState::Connect(ClientContext& context)
{
    Default(context);
}

void ClientState::ConnectionSuccessful(ClientContext& context)
{
    Default(context);
}

void ClientState::ConnectionUnsuccessful(ClientContext& context)
{
    Default(context);
}

void ClientState::Disconnect(ClientContext& context)
{
    Default(context);
}

void ClientState::DisconnectionSuccessful(ClientContext& context)
{
    Default(context);
}

void ClientState::DisconnectionUnsuccessful(ClientContext& context)
{
    Default(context);
}

void ClientState::Dispose(ClientContext& context)
{
    Default(context);
}

void ClientState::Default(ClientContext& context)
{
    throw (
        TransitionUndefinedException(
            (context.getState()).getName(),
            context.getTransition()));

}

void ClientMap_Disconnected::Connect(ClientContext& context)
{
    Client& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.ConnectToServerAsync();
        context.setState(ClientMap::Connecting);
    }
    catch (...)
    {
        context.setState(ClientMap::Connecting);
        throw;
    }
    context.getState().Entry(context);


}

void ClientMap_Disconnected::Dispose(ClientContext& context)
{
    Client& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.CleanupSocket();
        context.setState(ClientMap::Disposed);
    }
    catch (...)
    {
        context.setState(ClientMap::Disposed);
        throw;
    }
    context.getState().Entry(context);


}

void ClientMap_Connecting::ConnectionSuccessful(ClientContext& context)
{
    Client& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.NotifyConnected();
        context.setState(ClientMap::Connected);
    }
    catch (...)
    {
        context.setState(ClientMap::Connected);
        throw;
    }
    context.getState().Entry(context);


}

void ClientMap_Connecting::ConnectionUnsuccessful(ClientContext& context)
{
    Client& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.NotifyFailureToConnect();
        context.setState(ClientMap::Disconnected);
    }
    catch (...)
    {
        context.setState(ClientMap::Disconnected);
        throw;
    }
    context.getState().Entry(context);


}

void ClientMap_Connected::Disconnect(ClientContext& context)
{
    Client& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.DisconnectFromServerAsync();
        context.setState(ClientMap::Disconnecting);
    }
    catch (...)
    {
        context.setState(ClientMap::Disconnecting);
        throw;
    }
    context.getState().Entry(context);


}

void ClientMap_Disconnecting::DisconnectionSuccessful(ClientContext& context)
{
    Client& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.NotifyDisconnected();
        context.setState(ClientMap::Disconnected);
    }
    catch (...)
    {
        context.setState(ClientMap::Disconnected);
        throw;
    }
    context.getState().Entry(context);


}

void ClientMap_Disconnecting::DisconnectionUnsuccessful(ClientContext& context)
{
    Client& ctxt = context.getOwner();

    context.getState().Exit(context);
    context.clearState();
    try
    {
        ctxt.NotifyFailureToDisconnect();
        context.setState(ClientMap::Disconnected);
    }
    catch (...)
    {
        context.setState(ClientMap::Disconnected);
        throw;
    }
    context.getState().Entry(context);


}

//
// Local variables:
//  buffer-read-only: t
// End:
//
